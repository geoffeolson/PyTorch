I have done another review of the covariance matricies comeing from EKF, and here are my conclusions. Let me know what you think.

1. MOTION COVARIANCE MATRIX
As shown from the code snippet below, sigma_control is a covariance matrix in the control space [right, left].  It depennds on the vlues of left and right.  So the greater the left the greater the variance in the left coordinate. [left, right] is not the space used to optimize the pose, however sigma_control is mutiplied by dg_dcontrol, which converts the covariance from [left, right] space to 3D pose space. The values used to create sigma_control and dg_dcontrol do not change when the optimizer changes the pose so the covariance matrix does not need to be recalculated with each iteration.

left, right = control
a1 = self.control_motion_factor
a2 = self.control_turn_factor
Gl2 = (a1 * left)**2 + (a2 * (left - right))**2
Gr2 = (a1 * right)**2 + (a2 * (left - right))**2
sigma_control = diag([Gl2, Gr2])
Vt = self.dg_dcontrol(self.state, control, self.robot_width)
Rt = np.dot(Vt, np.dot(sigma_control, Vt.T))
 
 
2. OBSERVATION COVARIANCE MATRIX
As shown from the code snippet below, the current covariance matrix for the observation in EKF is in polar coordiantes:
 sigma_r = self.measurement_distance_stddev
 sigma_a = self.measurement_angle_stddev
 Q = np.diag([sigma_r**2, sigma_a**2])
 
 This makes sense, because the error in distance will be differnt than error in angle.  Distance and angle are also likely to be independant and uncorrelated. This means the GraphSLAM class should be modified to change the following in polar coordinates:
 
 (z) measurment
 (e) error
 (J) jacobian matrix
 (Sigma) covariance matrix
 
 Because of this we should look at reusing some code in EKF if possible. This goes against our origianal design intentent, but these calculations may be complex, so they should not be duplicated.  I think you may have been illuding to this in some of your code proposals, but I was not understanding the significance.